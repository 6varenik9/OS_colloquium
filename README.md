# Коллоквиум по Операционным Системам

# Общиие вопросы:

### 1) Что такое ООП? – полное определение

Объектно-ориентированное программирование (ООП) — это парадигма программирования, основанная на концепции объектов, которые являются экземплярами классов. Основные принципы ООП:

- **Инкапсуляция** — скрытие внутреннего состояния объекта и предоставление только необходимых методов для взаимодействия с объектом.
- **Наследование** — возможность создавать новые классы, которые наследуют свойства и поведение от существующих классов.
- **Полиморфизм** — способность объектов разных классов обрабатывать одинаковые сообщения (методы) по-разному.
- **Абстракция** — выделение важных характеристик объекта, игнорируя несущественные детали.


### 2) Магическое число 7 Миллера? – привести не менее 7 примеров из IT

Магическое число 7 Миллера связано с ограничением кратковременной памяти человека, который может воспринимать и удерживать не более 7 ± 2 единиц информации одновременно. В контексте IT это правило используется для упрощения интерфейсов и работы с данными.

Примеры:
1. **Размер страниц в веб-приложениях**: Обычно интерфейсы состоят из не более 7 элементов на одной странице для удобства восприятия.
2. **Клавиши на клавиатуре**: Клавиши функциональных клавиш F1-F12 (всего 12) делятся на две группы по 7 для удобства запоминания.
3. **Меню приложений**: В мобильных приложениях меню ограничены 7-ю опциями, чтобы пользователи могли быстро выбирать действия.
4. **Пакеты данных в сети**: Размер стандартного пакета TCP/IP часто находится в пределах от 7 до 10 байт для оптимизации передачи.
5. **Количество главных пунктов в документации**: В документации или инструкциях часто встречается ограничение на количество главных пунктов (например, 7 шагов для простоты усвоения).
6. **Количество ссылок на странице**: Исследования показывают, что страницы с 7 или менее ссылками могут быть более эффективными для пользователя.
7. **Число шардов в базах данных**: В распределенных системах, таких как MongoDB, количество шардов часто ограничено числом 7 для упрощения управления.

### 3) Энтропия ПО? – привести не менее 5 примеров нег энтропийных мер при разработке ПО

Энтропия ПО — это мера неопределенности или хаоса в системе. Чем выше энтропия, тем труднее поддерживать и развивать систему. Меры, снижающие энтропию, включают различные практики и подходы, упрощающие взаимодействие с кодом.

Примеры нег энтропийных мер:
1. **Код-ревью** — процесс проверки кода коллегами помогает снизить сложность и улучшить качество кода.
2. **Модульное тестирование** — регулярное написание тестов снижает неопределенность в коде и помогает выявлять ошибки.
3. **Соблюдение стандартов кодирования** — использование единого стиля кодирования (например, PEP 8 для Python) способствует лучшему восприятию и поддерживаемости кода.
4. **Документирование кода** — наличие подробной документации уменьшает неопределенность и упрощает взаимодействие с кодом для других разработчиков.
5. **Использование паттернов проектирования** — применение проверенных решений (например, Singleton, Factory) помогает структурировать код и уменьшает его сложность.

### 4) 5 признаков сложной системы по Гради Бучу – по каждому признаку привести не менее 2-х пояснительных примеров из ваших лабораторных работ или pet проектов

Гради Буч выделяет 5 признаков, которые характеризуют сложные системы:

1. **Большое количество элементов** — система состоит из множества взаимосвязанных компонентов.
   - **Пример 1**: В лабораторной работе по многозадачности взаимодействие между несколькими потоками, работающими с общими данными.
   - **Пример 2**: В проекте по разработке игры множество объектов, таких как игроки, NPC, предметы, и их взаимодействие между собой.

2. **Невозможность предсказания поведения системы** — сложные системы часто имеют непредсказуемые взаимодействия между компонентами.
   - **Пример 1**: В многозадачных приложениях взаимодействие между потоками может привести к неожиданным результатам.
   - **Пример 2**: В проекте с асинхронным вводом-выводом могут возникать состояния гонки, которые трудно предсказать.

3. **Гибкость** — система должна быть способна адаптироваться к изменениям.
   - **Пример 1**: Использование паттерна проектирования "Стратегия" для изменения поведения игры в зависимости от состояния игрока.
   - **Пример 2**: В проекте по обработке данных создание модульных компонентов, которые можно заменить без изменения всей системы.

4. **Появление новых свойств** — система может демонстрировать новые, неожиданные свойства в ходе работы.
   - **Пример 1**: В проекте с многозадачностью появляются непредсказуемые проблемы, такие как deadlock или race conditions.
   - **Пример 2**: В проекте для работы с данными возникают неожиданные зависимости между различными данными, которые не были очевидны изначально.

5. **Самоорганизация** — элементы системы могут взаимодействовать и организовываться без внешнего контроля.
   - **Пример 1**: В проекте с сетевыми приложениями обмен данными между устройствами без централизованного сервера.
   - **Пример 2**: В проекте с клиент-серверной архитектурой может происходить автоматическое распределение нагрузки между серверами.

### 5) Закон иерархических компенсаций Седова – привести не менее 5 исторических примеров применения закона Седова в эволюции IT сферы

Закон иерархических компенсаций Седова описывает закономерности в сложных системах, где компенсация или восстановление баланса происходит через иерархические структуры. В контексте IT, этот закон можно трактовать как процесс стабилизации и адаптации систем через изменения и улучшения на различных уровнях.

Примеры:
1. **Микросервисы** — переход от монолитной архитектуры к микросервисам как иерархическая компенсация для улучшения масштабируемости и устойчивости систем.
2. **Облачные вычисления** — рост облачных сервисов как компенсация недостаточной гибкости традиционных дата-центров.
3. **Версионность программного обеспечения** — необходимость улучшения контроля версий и непрерывного развертывания для компенсации недостатков старых моделей разработки ПО.
4. **Децентрализованные системы** — использование блокчейна как ответ на проблемы с централизованными системами, обеспечивающими большую безопасность и автономность.
5. **Автоматизация и CI/CD** — использование систем непрерывной интеграции и доставки как компенсация для улучшения процессов разработки и устранения проблем с выпуском новых версий программного обеспечения.



# Нулевые вопросы:

### 1. Приведите Win API, необходимое для решения Лабораторной работы номер 3

Для выполнения лабораторной работы №3, которая включает в себя работу с несколькими потоками, синхронизацию между ними и работу с массивами, необходимо использовать несколько ключевых функций и объектов WinAPI.

- **CreateThread()** — для создания новых потоков.
- **WaitForSingleObject()** — для ожидания завершения потока или получения сигнала от потока.
- **SetEvent()** — для отправки сигнала о начале работы потока.
- **ResetEvent()** — для сброса состояния события, чтобы ожидать повторный сигнал.
- **CreateEvent()** — для создания объекта синхронизации типа "событие".
- **ReleaseMutex()** и **WaitForSingleObject()** — для работы с мьютексами (если необходимо для защиты общей памяти).
- **ExitThread()** — для завершения работы потока.
- **srand()** и **rand()** — для генерации случайных чисел.
- **malloc()** — для выделения памяти для массива.

Пример кода:
```cpp
#include <windows.h>
#include <iostream>

using namespace std;

HANDLE hEvent;
int *array;

DWORD WINAPI MarkerThread(LPVOID lpParam) {
    int id = *(int*)lpParam;
    srand(id);

    WaitForSingleObject(hEvent, INFINITE);

    while (true) {
        int randValue = rand();
        int index = randValue % 10;

        if (array[index] == 0) {
            Sleep(5);
            array[index] = id;
            Sleep(5);
        } else {
            cout << "Thread " << id << " cannot mark index " << index << endl;
            break;
        }
    }

    return 0;
}

int main() {
    int arraySize;
    cout << "Enter array size: ";
    cin >> arraySize;

    array = (int*)malloc(arraySize * sizeof(int));
    memset(array, 0, arraySize * sizeof(int));

    int numThreads;
    cout << "Enter number of threads: ";
    cin >> numThreads;

    hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    HANDLE *threads = new HANDLE[numThreads];
    int *threadIds = new int[numThreads];

    for (int i = 0; i < numThreads; i++) {
        threadIds[i] = i + 1;
        threads[i] = CreateThread(NULL, 0, MarkerThread, &threadIds[i], 0, NULL);
    }

    cout << "Press Enter to start threads...";
    cin.get();

    SetEvent(hEvent);

    WaitForMultipleObjects(numThreads, threads, TRUE, INFINITE);

    for (int i = 0; i < numThreads; i++) {
        CloseHandle(threads[i]);
    }

    free(array);
    delete[] threads;
    delete[] threadIds;

    return 0;
}

```

### 2. Что такое поток в ОС Windows

Поток (thread) в ОС Windows — это наименьшая единица выполнения в процессе. Потоки выполняются параллельно и могут разделять между собой ресурсы, такие как память и файловые дескрипторы, в рамках одного процесса. Каждый поток имеет свой собственный стек, регистры и уникальный идентификатор (ID).

Пример создания потока:
```cpp
DWORD WINAPI MyThread(LPVOID lpParam) {
    return 0;
}

int main() {
    HANDLE hThread = CreateThread(NULL, 0, MyThread, NULL, 0, NULL);
    WaitForSingleObject(hThread, INFINITE);
    CloseHandle(hThread);  
    return 0;
}
```

### 3. Что такое Мьютекс

Мьютекс (Mutual Exclusion Object) — это объект синхронизации, предназначенный для предотвращения одновременного доступа к ресурсу несколькими потоками. Он используется для обеспечения взаимного исключения при работе с общими ресурсами, такими как память или файлы. Мьютекс может быть захвачен только одним потоком, и только этот поток может его освободить.

Пример использования мьютекса:
```cpp
HANDLE hMutex = CreateMutex(NULL, FALSE, NULL);

DWORD WINAPI MyThread(LPVOID lpParam) {
    WaitForSingleObject(hMutex, INFINITE);
    ReleaseMutex(hMutex);  
    return 0;
}
```

### 4. Что такое Событие (объект синхронизации)

Событие — это объект синхронизации в Windows, который позволяет потокам синхронизировать свое выполнение. Потоки могут ожидать сигнала от другого потока или подавать сигнал для продолжения работы других потоков. Событие может быть в одном из двух состояний: сигнальном (set) или несигнальном (reset).

Пример использования события:
```cpp
HANDLE hEvent = CreateEvent(NULL, FALSE, FALSE, NULL); 

DWORD WINAPI MyThread(LPVOID lpParam) {
    WaitForSingleObject(hEvent, INFINITE);  
    return 0;
}

int main() {
    SetEvent(hEvent);
    return 0;
}
```

### 5. Сравнительный анализ стандарта C++ 98 и любого более свежего стандарта (в контексте лабораторных)

**C++98** и более свежие стандарты (например, **C++11, C++14, C++17, C++20**) значительно различаются по возможностям, доступным разработчику.

- **C++98**:
  - Не поддерживает многопоточность.
  - Нет встроенных средств для работы с регулярными выражениями (до C++11).
  - Нет лямбда-функций.
  - Для синхронизации использовались только низкоуровневые механизмы (например, мьютексы через WinAPI или PThreads).
  - Отсутствие уникальных и совместных указателей (smart pointers).

- **C++11** и новее:
  - **Многопоточность**: C++11 ввел стандартные библиотеки для работы с многозадачностью, такие как `<thread>`, `<mutex>`, `<future>`, что значительно упрощает реализацию многозадачных приложений.
  - **Лямбда-функции**: позволяют более лаконично и удобно описывать функции и их использование.
  - **Умные указатели** (например, `std::unique_ptr`, `std::shared_ptr`) обеспечивают автоматическое управление памятью.
  - **Регулярные выражения**: стандартная библиотека теперь включает поддержку регулярных выражений через `<regex>`.
  - **Статическая и динамическая синхронизация**: с помощью стандартных библиотек можно использовать мьютексы и другие объекты синхронизации без обращения к низкоуровневым API.

Пример с `thread` из C++11:
```cpp
#include <iostream>
#include <thread>

using namespace std;

void myFunction() {
    cout << "Hello from thread!" << endl;
}

int main() {
    thread t(myFunction);  
    t.join(); 
    return 0;
}
```

Таким образом, C++11 и новее значительно упрощают работу с многозадачностью и синхронизацией, делая код более читаемым и безопасным.
